name: 파처 두 번째 과제 CI

on:
  push:
    branches:
      - feat/*
      - test
      - main
jobs:
  project1-test:
    if: false
    runs-on: ubuntu-22.04

    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4

      - name: C 컴파일러 설치
        run: sudo apt update && sudo apt install -y gcc

      - name: copy normal file
        #if: github.ref == 'refs/heads/feat/copy'
        run: |
          gcc copy.c
          echo -n "1234567891123456" > testfile.txt
          ./a.out testfile.txt copy_test.txt
          diff testfile.txt copy_test.txt && echo -n "✅ normal file 복사 테스트 통과" || exit 1
          rm testfile.txt copy_test.txt

      - name: copy empty file
        #if: github.ref == 'refs/heads/feat/copy'
        run: |
          gcc copy.c
          touch empty.txt
          ./a.out empty.txt empty_copy.txt
          diff empty.txt empty_copy.txt && echo -n "✅ empty file 복사 테스트 통과" || exit 1
          rm empty.txt empty_copy.txt

      - name: copy binary file
        #if: github.ref == 'refs/heads/feat/copy'
        run: |
          gcc copy.c
          head -c 1048576 /dev/urandom > binary_source.bin
          ./a.out binary_source.bin binary_dest.bin
          diff binary_source.bin binary_dest.bin && echo -n "✅ binary file 복사 테스트 통과"|| exit 1
          rm binary_source.bin binary_dest.bin

      - name: merge.c 컴파일 및 테스트
        #if: github.ref == 'refs/heads/feat/merge'
        run: |
          gcc merge.c
          echo -n "1234567890" > file1.txt
          echo -n "abcdefghij" > file2.txt
          ./a.out merged.txt file1.txt file2.txt
          cat file1.txt file2.txt > expected.txt
          
          # 파일 크기 체크 (stat 사용)
          expected_size=$(stat -c %s expected.txt)
          merged_size=$(stat -c %s merged.txt)

          echo -n "Expected Size: $expected_size bytes"
          echo -n "Merged Size:   $merged_size bytes"

          if [ "$expected_size" -ne "$merged_size" ]; then
            echo -n "파일 크기 불일치 (병합 실패)"
            exit 1
          fi

          # 파일 내용 체크 (diff 사용)
          if diff merged.txt expected.txt; then
            echo -n "병합 테스트 통과"
          else
            echo -n "파일 내용 불일치"
            exit 1
          fi

      - name: read normal file
        #if: github.ref == 'refs/heads/feat/read'
        run: |
          gcc read.c
          echo -n "abcdefghijklmnopqrstuvwxyz" > readtest.txt
          
          # ✅ 테스트 1: 정상적인 경우
          ./a.out 5 5 readtest.txt > output.txt
          echo "fghij" > expected_read.txt
          diff output.txt expected_read.txt && echo -n "✅ 테스트 1 통과" || exit 1
          
          # ✅ 테스트 2: 바이트 수가 0 (출력 없음)
          rm -f output.txt
          ./a.out 5 0 readtest.txt > output.txt
          if [ $? -eq 0 ] && [ ! -s output.txt ]; then
          echo -n "✅ 테스트 2 통과"
          else
          echo "❌ 테스트 2 실패"
          exit 1
          fi
          
          # ✅ 테스트 3: 파일 끝까지 읽는 경우
          ./a.out 20 10 readtest.txt > output.txt
          echo "uvwxyz" > expected_read.txt
          diff output.txt expected_read.txt && echo -n "✅ 테스트 3 통과" || exit 1
          
          # ✅ 테스트 4: 오프셋이 파일 크기를 초과하는 경우 (출력 없음)
          rm -f output.txt
          ./a.out 30 5 readtest.txt > output.txt
          
          # 파일 존재 여부뿐만 아니라 크기가 0인지도 검사
          if [ $? -eq 0 ] && [ ! -s output.txt ]; then
          echo -n "✅ 테스트 4 통과"
          else
          echo "❌ 테스트 4 실패"
          exit 1
          fi
          
          # ✅ 테스트 5: 오프셋이 파일 끝일 경우 (출력 없음)
          rm -f output.txt
          ./a.out 26 5 readtest.txt > output.txt
          if [ $? -eq 0 ] && ([ ! -f output.txt ] || [ ! -s output.txt ]); then
          echo -n "✅ 테스트 5 통과"
          else
          echo "❌ 테스트 5 실패"
          exit 1
          fi

          # ✅ 테스트 6: 파일 전체 읽기
          ./a.out 0 26 readtest.txt > output.txt
          echo "abcdefghijklmnopqrstuvwxyz" > expected_read.txt
          diff output.txt expected_read.txt && echo -n "✅ 테스트 6 통과" || exit 1

      - name: write.c 컴파일 및 테스트
        #if: github.ref == 'refs/heads/feat/write'
        run: |
          gcc write.c
          echo -n "abcdefghij" > writetest.txt
          
          # ✅ 테스트 1: 일반적인 덮어쓰기
          ./a.out 3 "XYZ" writetest.txt
          echo -n "abcXYZghij" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 1 통과" || exit 1

          # ✅ 테스트 2: 파일 끝에서 덮어쓰기 (EOF 넘어감)
          echo -n "abcdefghij" > writetest.txt
          ./a.out 8 "XYZ" writetest.txt
          echo -n "abcdefghXYZ" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 2 통과" || exit 1

          # ✅ 테스트 3: 파일 크기보다 큰 오프셋에서 덮어쓰기 (빈 공간 생성)
          echo -n "abcdefghij" > writetest.txt
          ./a.out 15 "XYZ" writetest.txt
          printf "abcdefghij\x00\x00\x00\x00\x00XYZ" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 3 통과" || exit 1

          # ✅ 테스트 4: 파일 처음부터 덮어쓰기
          echo -n "abcdefghij" > writetest.txt
          ./a.out 0 "XYZ" writetest.txt
          echo -n "XYZdefghij" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 4 통과" || exit 1

          # ✅ 테스트 5: 파일 전체 덮어쓰기 (파일 크기보다 큰 데이터)
          echo -n "abcdefghij" > writetest.txt
          ./a.out 0 "ABCDEFGHIJKLMNO" writetest.txt
          echo -n "ABCDEFGHIJKLMNO" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 5 통과" || exit 1

          # ✅ 테스트 6: 오프셋이 0이고 데이터가 빈 문자열
          echo -n "abcdefghij" > writetest.txt
          ./a.out 0 "" writetest.txt
          echo -n "abcdefghij" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 6 통과" || exit 1

          # ✅ 테스트 7: 오프셋이 파일 끝이고 데이터가 빈 문자열
          echo -n "abcdefghij" > writetest.txt
          ./a.out 10 "" writetest.txt
          echo -n "abcdefghij" > expected_write.txt
          diff writetest.txt expected_write.txt && echo -n "✅ 테스트 7 통과" || exit 1

      - name: insert.c 컴파일 및 테스트
        #if: github.ref == 'refs/heads/feat/insert'
        run: |
          gcc insert.c
          echo -n "abcdefghij" > inserttest.txt
          
          # ✅ 테스트 1: 일반적인 끼워넣기 (5와 6 사이에 "XYZ" 삽입)
          ./a.out 5 "XYZ" inserttest.txt
          echo -n "abcdefXYZghij" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 1 통과" || exit 1

          # ✅ 테스트 2: 파일 끝에서 끼워넣기 (append 처리)
          echo -n "abcdefghij" > inserttest.txt
          ./a.out 10 "XYZ" inserttest.txt
          echo -n "abcdefghijXYZ" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 2 통과" || exit 1

          # ✅ 테스트 3: 파일 처음에 데이터 삽입
          echo -n "abcdefghij" > inserttest.txt
          ./a.out 0 "XYZ" inserttest.txt
          echo -n "aXYZbcdefghij" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 3 통과" || exit 1

          # ✅ 테스트 4: 파일 크기를 초과하는 오프셋 (append 처리)
          echo -n "abcdefghij" > inserttest.txt
          ./a.out 15 "XYZ" inserttest.txt
          echo -n "abcdefghijXYZ" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 4 통과" || exit 1

          # ✅ 테스트 5: 빈 문자열 삽입 (변경 없음)
          echo -n "abcdefghij" > inserttest.txt
          ./a.out 5 "" inserttest.txt
          echo -n "abcdefghij" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 5 통과" || exit 1

          # ✅ 테스트 6: 오프셋이 파일 끝이고 빈 문자열 삽입 (변경 없음)
          echo -n "abcdefghij" > inserttest.txt
          ./a.out 10 "" inserttest.txt
          echo -n "abcdefghij" > expected_insert.txt
          diff inserttest.txt expected_insert.txt && echo -n "✅ 테스트 6 통과" || exit 1

      - name: delete.c 컴파일 및 테스트
        #if: github.ref == 'refs/heads/feat/delete'
        run: |
          gcc delete.c
          echo -n "abcdefghij" > deletetest.txt
          
          # ✅ 테스트 1: 일반적인 삭제 (2번 오프셋부터 3바이트 삭제)
          ./a.out 2 3 deletetest.txt
          echo -n "abfghij" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 1 통과" || exit 1

          # ✅ 테스트 2: 파일 끝에서 일부 삭제
          echo -n "abcdefghij" > deletetest.txt
          ./a.out 7 3 deletetest.txt
          echo -n "abcdefg" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 2 통과" || exit 1

          # ✅ 테스트 3: 파일 전체 삭제
          echo -n "abcdefghij" > deletetest.txt
          ./a.out 0 10 deletetest.txt
          echo -n "" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 3 통과" || exit 1

          # ✅ 테스트 4: 바이트 수가 0인 경우 (변경 없음)
          echo -n "abcdefghij" > deletetest.txt
          ./a.out 3 0 deletetest.txt
          echo -n "abcdefghij" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 4 통과" || exit 1

          # ✅ 테스트 5: 삭제할 바이트 수가 파일 크기를 초과하는 경우
          echo -n "abcdefghij" > deletetest.txt
          ./a.out 3 20 deletetest.txt
          echo -n "abc" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 5 통과" || exit 1

          # ✅ 테스트 6: 오프셋이 파일 크기를 초과하는 경우 (변경 없음)
          echo -n "abcdefghij" > deletetest.txt
          ./a.out 15 3 deletetest.txt
          echo -n "abcdefghij" > expected_delete.txt
          diff deletetest.txt expected_delete.txt && echo -n "✅ 테스트 6 통과" || exit 1

      - name: copy 멀티라인 파일 테스트
        run: |
          gcc copy.c
          cat <<EOF > multiline_source.txt
          첫번째 줄
          두번째 줄
          세번째 줄
          EOF
          ./a.out multiline_source.txt multiline_dest.txt
          diff multiline_source.txt multiline_dest.txt && echo -n "✅ 멀티라인 파일 복사 테스트 통과" || exit 1
          rm multiline_source.txt multiline_dest.txt

      - name: merge 멀티라인 파일 테스트
        run: |
          gcc merge.c
          cat <<EOF > file1_multiline.txt
          첫번째 줄
          두번째 줄
          EOF
          cat <<EOF > file2_multiline.txt
          세번째 줄
          네번째 줄
          EOF
          ./a.out output_multiline.txt file1_multiline.txt file2_multiline.txt
          cat file1_multiline.txt file2_multiline.txt > expected_multiline.txt
          diff output_multiline.txt expected_multiline.txt && echo -n "✅ 멀티라인 파일 병합 테스트 통과" || exit 1
          rm file1_multiline.txt file2_multiline.txt expected_multiline.txt output_multiline.txt

      - name: read 멀티라인 테스트
        run: |
          gcc read.c
          cat <<EOF > multiline_test.txt
          line1
          line2
          line3
          EOF
          expected_output=$(printf "line1\nline2\nline3")
          output=$(./a.out 0 17 multiline_test.txt)
          if [ "$output" != "$expected_output" ]; then
            echo "❌ 멀티라인 read 테스트 실패: 예상 결과 '$expected_output', 실제 결과 '$output'"
            exit 1
          else
            echo -n "✅ 멀티라인 read 테스트 통과"
          fi
          rm multiline_test.txt

      - name: write 멀티라인 테스트
        run: |
          gcc write.c
          cat <<EOF > test_write_multiline.txt
          line1
          line2
          line3
          EOF
          ./a.out 6 "NEW" test_write_multiline.txt
          expected_content=$(printf "line1\nNEWe2\nline3")
          actual_content=$(cat test_write_multiline.txt)
          if [ "$actual_content" != "$expected_content" ]; then
            echo "❌ write 멀티라인 테스트 실패: 예상 결과 '$expected_content', 실제 결과 '$actual_content'"
            exit 1
          else
            echo -n "✅ write 멀티라인 테스트 통과"
          fi
          rm test_write_multiline.txt

      - name: insert 멀티라인 테스트
        run: |
          gcc insert.c
          printf "line1\nline2\nline3" > insert_multiline.txt
          ./a.out 6 "INSERT" insert_multiline.txt
          expected=$(printf "line1\nlINSERTine2\nline3")
          diff insert_multiline.txt <(echo -n "$expected") && echo -n "✅ insert 멀티라인 테스트 통과" || exit 1
          rm insert_multiline.txt

      - name: delete 멀티라인 테스트
        run: |
          gcc delete.c
          printf "line1\nline2\nline3" > delete_multiline.txt
          ./a.out 6 3 delete_multiline.txt
          expected=$(printf "line1\ne2\nline3")
          diff delete_multiline.txt <(echo -n "$expected") && echo -n "✅ delete 멀티라인 테스트 통과" || exit 1
          rm delete_multiline.txt  

  project2-test:
    runs-on: ubuntu-22.04

    steps:
      - name: 저장소 체크아웃
        uses: actions/checkout@v4

      - name: C 컴파일러 설치
        run: sudo apt update && sudo apt install -y gcc

      - name: flashmemory 생성 테스트
        run: |
          gcc -o a.out ftlmgr.c fdevicedriver.c
          
          echo "컴파일 완료"
          file a.out
          
          for BLOCKS in 0 1 5 10 20; do
            echo "✅ 블록 수 $BLOCKS로 flashmemory 생성 테스트"
            rm -f flashmemory  # 이전 파일 삭제
            ./a.out c flashmemory $BLOCKS
          
            EXPECTED_SIZE=$((BLOCKS * 8 * 528))
            FILESIZE=$(stat --format=%s flashmemory)
          
            echo "flashmemory 크기: $FILESIZE 바이트 (예상: $EXPECTED_SIZE 바이트)"
          
            if [ "$FILESIZE" -ne "$EXPECTED_SIZE" ]; then
              echo "❌ 실패: 예상 $EXPECTED_SIZE 바이트, 실제 $FILESIZE 바이트"
              exit 1
            else
              echo "✅ 성공: 크기 일치 ($EXPECTED_SIZE 바이트)"
            fi
          
            echo ""
          done

      - name: write 명령 테스트
        run: |
          gcc -o a.out ftlmgr.c fdevicedriver.c

          # Step 2: 페이지 2번에 쓰기
          ./a.out w flashmemory 2 "helloCI" "123"

          # Step 3: 해당 위치 읽어서 데이터 확인
          OFFSET=$((2 * 528))
          hexdump -C -n 16 -s $OFFSET flashmemory > written.txt
          grep -q "68 65 6c 6c 6f 43 49" written.txt && echo "✅ write 성공" || (echo "❌ write 실패" && exit 1)

          # Step 4: 같은 위치에 다시 쓰기 시도 (거부되어야 함)
          ./a.out w flashmemory 2 "overwrite" "456" > try.txt

          # Step 5: 덮어쓰기 안 된 것 확인
          hexdump -C -n 16 -s $OFFSET flashmemory > written2.txt
          grep -q "helloCI" written2.txt && echo "✅ 덮어쓰기 방지 확인" || (echo "❌ 덮어쓰기 방지 실패" && exit 1)

          # 정리
          rm -f flashmemory written.txt written2.txt try.txt

      - name: read 명령 테스트
        run: |
          gcc -o a.out ftlmgr.c fdevicedriver.c
          
          #  테스트 1: 정상적인 읽기
          ./a.out w flashmemory 2 "abcd12345@%$" "12"
          ./a.out r flashmemory 2 > r1.txt
          grep -q "abcd12345@%$ 12" r1.txt && echo "✅ read 테스트 1 통과" || (echo "❌ read 테스트 1 실패" && cat r1.txt && exit 1)
          rm flashmemory

          #  테스트 2: sector가 비어 있으면 출력 안 함
          ./a.out w flashmemory 2 "" "12"
          ./a.out r flashmemory 2 > r2.txt
          [ ! -s r2.txt ] && echo "✅ read 테스트 2 통과" || (echo "❌ read 테스트 2 실패 (출력 있음)" && cat r2.txt && exit 1)
          rm flashmemory

          #  테스트 3: 완전 빈 페이지 (아무것도 안 씀)
          ./a.out c flashmemory 4
          ./a.out r flashmemory 4 > r3.txt
          [ ! -s r3.txt ] && echo "✅ read 테스트 3 통과" || (echo "❌ read 테스트 3 실패 (출력 있음)" && cat r3.txt && exit 1)

          #  테스트 4: 덮어쓰기 방지된 페이지 읽기
          ./a.out w flashmemory 5 "firstdata" "55"
          ./a.out w flashmemory 5 "second" "99"  # 무시돼야 함
          ./a.out r flashmemory 5 > r4.txt
          grep -q "firstdata 55" r4.txt && echo "✅ read 테스트 4 통과" || (echo "❌ read 테스트 4 실패" && cat r4.txt && exit 1)

          #  정리
          rm -f flashmemory r1.txt r2.txt r3.txt r4.txt

      - name: erase 명령 테스트
        run: |
          # ✅ Step 1: 플래시 생성 (1 블록 = 8 페이지)
          ./a.out c flashmemory 1

          # ✅ Step 2: 페이지에 데이터 작성 (ppn = 4는 block 0에 속함)
          ./a.out w flashmemory 4 "beforeErase" "999"
          ./a.out r flashmemory 4 > before.txt
          grep -q "beforeErase 999" before.txt && echo "✅ erase 전 쓰기 확인" || (echo "❌ 쓰기 실패" && cat before.txt && exit 1)

          # ✅ Step 3: 블록 0 소거
          ./a.out e flashmemory 0

          # ✅ Step 4: 소거된 페이지는 출력 없어야 함 (sector, spare 모두 지워졌는지)
          ./a.out r flashmemory 4 > after.txt
          [ ! -s after.txt ] && echo "✅ erase 후 페이지 초기화 확인" || (echo "❌ erase 실패 (데이터 남음)" && cat after.txt && exit 1)

          # ✅ 정리
          rm -f flashmemory before.txt after.txt

      - name: update 명령 다양한 케이스 테스트
        run: |
          #########################################
          echo "🧪 T1. 기본 update 동작 테스트"
          ./a.out c flashmemory 3
          ./a.out w flashmemory 11 "old" "11"
          ./a.out u flashmemory 11 "newData!" "99" > log1.txt
          ./a.out r flashmemory 11 > out1.txt
          grep -q "newData! 99" out1.txt && echo "✅ T1 통과" || (echo "❌ T1 실패" && cat out1.txt && exit 1)

          #########################################
          echo "🧪 T2. 같은 페이지에 두 번 연속 update"
          ./a.out u flashmemory 11 "second" "88" > log2.txt
          ./a.out r flashmemory 11 > out2.txt
          grep -q "second 88" out2.txt && echo "✅ T2 통과" || (echo "❌ T2 실패" && cat out2.txt && exit 1)

          #########################################
          echo "🧪 T3. 나머지 페이지 보존 확인"
          ./a.out w flashmemory 10 "stay" "22"
          ./a.out u flashmemory 11 "final!" "44"
          ./a.out r flashmemory 10 > out3.txt
          grep -q "stay 22" out3.txt && echo "✅ T3 통과" || (echo "❌ T3 실패 - 다른 페이지 손실" && cat out3.txt && exit 1)

          #########################################
          echo "🧪 T5. sector는 그대로, spare만 변경"
          ./a.out c flashmemory 3
          ./a.out w flashmemory 9 "constant" "33"
          ./a.out u flashmemory 9 "constant" "77"
          ./a.out r flashmemory 9 > out5.txt
          grep -q "constant 77" out5.txt && echo "✅ T5 통과" || (echo "❌ T5 실패 - spare 변경 안 됨" && cat out5.txt && exit 1)

          #########################################
          echo "🧹 테스트 종료 후 정리"
          rm -f flashmemory out*.txt log*.txt
      - name: 추가 테스트
        run: |
          gcc -o a.out ftlmgr.c fdevicedriver.c

          echo "🧪 T6. write → read → erase → read: 페이지 완전 초기화 확인"
          ./a.out c flashmemory 2
          ./a.out w flashmemory 4 "eraseCheck" "55"
          ./a.out r flashmemory 4 > beforeErase.txt
          grep -q "eraseCheck 55" beforeErase.txt || (echo "❌ T6 실패 - write 또는 read 실패" && cat beforeErase.txt && exit 1)
          ./a.out e flashmemory 0
          ./a.out r flashmemory 4 > afterErase.txt
          [ ! -s afterErase.txt ] && echo "✅ T6 통과" || (echo "❌ T6 실패 - erase 후에도 데이터 존재" && cat afterErase.txt && exit 1)

          echo "🧪 T7. 최대 페이지 번호(ppn = 8*block - 1)에 쓰고 읽기"
          ./a.out c flashmemory 3
          MAX_PPN=$((8*3 - 1))
          ./a.out w flashmemory $MAX_PPN "maxPage" "77"
          ./a.out r flashmemory $MAX_PPN > out7.txt
          grep -q "maxPage 77" out7.txt && echo "✅ T7 통과" || (echo "❌ T7 실패 - 최대 페이지 처리 실패" && cat out7.txt && exit 1)

          echo "🧪 T8. update 시 빈 블록을 제대로 탐색했는지 확인"
          ./a.out c flashmemory 5
          ./a.out w flashmemory 8 "original" "88"
          ./a.out u flashmemory 8 "updated" "99"
          ./a.out r flashmemory 8 > out8.txt
          grep -q "updated 99" out8.txt && echo "✅ T8 통과" || (echo "❌ T8 실패 - update 실패" && cat out8.txt && exit 1)

          echo "🧪 T9. update 과정 중 다른 페이지가 보존되는지 검증"
          ./a.out c flashmemory 4
          ./a.out w flashmemory 15 "preserved" "15"
          ./a.out w flashmemory 16 "toupdate" "16"
          ./a.out u flashmemory 16 "changed" "77"
          ./a.out r flashmemory 15 > out9.txt
          grep -q "preserved 15" out9.txt && echo "✅ T9 통과" || (echo "❌ T9 실패 - 보존되지 않음" && cat out9.txt && exit 1)

          echo "🧪 T10. 완전 초기화된 페이지 읽기 → 출력 없음"
          ./a.out c flashmemory 2
          ./a.out r flashmemory 0 > out10.txt
          [ ! -s out10.txt ] && echo "✅ T10 통과" || (echo "❌ T10 실패 - 초기화된 페이지 출력됨" && cat out10.txt && exit 1)

          echo "🧪 T11. spare 데이터가 0일 때 정상 출력되는지 확인"
          ./a.out c flashmemory 2
          ./a.out w flashmemory 1 "dataZero" "0"
          ./a.out r flashmemory 1 > out11.txt
          grep -q "dataZero 0" out11.txt && echo "✅ T11 통과" || (echo "❌ T11 실패 - spare=0 출력 안 됨" && cat out11.txt && exit 1)

          echo "🧪 T12. 연속 페이지 write-read 테스트"
          ./a.out c flashmemory 2
          for i in {0..7}; do
            ./a.out w flashmemory $i "page$i" "$i"
          done
          for i in {0..7}; do
            ./a.out r flashmemory $i > out12_$i.txt
            grep -q "page$i $i" out12_$i.txt || (echo "❌ T12 실패 - ppn $i" && cat out12_$i.txt && exit 1)
          done
          echo "✅ T12 통과"

          echo "🧹 정리"
          rm -f flashmemory beforeErase.txt afterErase.txt out*.txt

      - name: create flash memory
        run: |
          gcc ftlmgr.c fdevicedriver.c -o a.out
          
          for BLOCKS in 5 10 20; do
          FILE="flashmemory_$BLOCKS"
          
          ./a.out c $FILE $BLOCKS
          
          # 예상 크기 계산: BLOCKS * 8 * (512 + 16)
          EXPECTED_SIZE=$((BLOCKS * 8 * 528))
          FILESIZE=$(stat --format=%s $FILE)
          
          echo "📏 [$FILE] 크기: $FILESIZE 바이트 (예상: $EXPECTED_SIZE 바이트)"
          
          if [ "$FILESIZE" -ne "$EXPECTED_SIZE" ]; then
          echo "❌ 파일 크기 오류: 예상 $EXPECTED_SIZE 바이트, 실제 $FILESIZE 바이트"
          exit 1
          else
          echo "✅ 파일 크기 정상 ($EXPECTED_SIZE 바이트)"
          fi
          
          echo ""
          done

      - name: write page
        run: |
          gcc ftlmgr.c fdevicedriver.c -o a.out
          
          #############################
          # TEST 1: 일반적인 경우
          #############################
          
          ./a.out c flashmemory 10
          ./a.out w flashmemory 5 "abc123!" "42"
          
          dd if=flashmemory bs=528 skip=5 count=1 of=readpage.bin status=none
          
          echo ""
          echo "test 1 분석"
          
          # ✅ 섹터 문자열 확인 및 검사
          SECTOR_STRING=$(dd if=readpage.bin bs=1 count=512 status=none | strings | head -n 1)
          EXPECTED_SECTOR="abc123!"
          
          if [ "$SECTOR_STRING" != "$EXPECTED_SECTOR" ]; then
          echo "❌ 섹터 영역 문자열 불일치!"
          echo "   입력한 섹터 데이터: $EXPECTED_SECTOR"
          echo "   저장된 섹터 데이터: $SECTOR_STRING"
          echo "💥 write-page-test 1 테스트 실패!"
          exit 1
          else
          echo "✅ 섹터 영역 문자열 확인 완료: \"$SECTOR_STRING\""
          fi
          
          # ✅ 스페어 영역 검사
          SPARE_HEX=$(xxd -s 512 -l 4 -p readpage.bin)
          EXPECTED_SPARE="2a000000"
          
          if [ "$SPARE_HEX" != "$EXPECTED_SPARE" ]; then
          echo "❌ 스페어 영역 binary 값이 예상과 다름! (42 → $EXPECTED_SPARE)"
          echo "💥 write-page-test 1 실패!"
          exit 1
          else
          echo "✅ 스페어 영역 binary 값 확인 완료 (42 → $EXPECTED_SPARE)"
          fi
          
          # ✅ 최종 통과 메시지
          echo "🎉 write-page-test 1 성공!"
          
          #############################
          # TEST 2: 빈 섹터 데이터 확인
          #############################
          ./a.out c flashmemory 10
          ./a.out w flashmemory 6 "" "77"
          
          dd if=flashmemory bs=528 skip=6 count=1 of=readpage2.bin status=none
          
          echo ""
          echo "test 2 분석 (빈 섹터)"
          
          SECTOR_BYTES=$(dd if=readpage2.bin bs=1 count=512 status=none | hexdump -v -e '/1 "%02x"')
          
          # 전부 0xFF인지 확인
          if [[ "$SECTOR_BYTES" != $(printf 'ff%.0s' {1..512}) ]]; then
          echo "❌ 섹터 영역이 0xFF로 초기화되지 않음!"
          echo "💥 write-page-test 2 실패!"
          exit 1
          else
          echo "✅ 빈 섹터 데이터 → 섹터 영역이 0xFF로 초기화됨"
          fi
          
          SPARE_HEX=$(xxd -s 512 -l 4 -p readpage2.bin)
          if [ "$SPARE_HEX" != "4d000000" ]; then  # 77 = 0x4d = 4d000000 (little endian)
          echo "❌ 스페어 값이 77(4d000000)로 저장되지 않음!"
          echo "💥 write-page-test 2 실패!"
          exit 1
          else
          echo "✅ 스페어 영역 binary 값 확인 완료 (77 → $SPARE_HEX)"
          echo "🎉 write-page-test 2 성공!"
          fi
          
          #############################
          # TEST 3: 빈 스페어 데이터 확인
          #############################
          ./a.out c flashmemory 10
          ./a.out w flashmemory 7 "xyz!!" ""
          
          dd if=flashmemory bs=528 skip=7 count=1 of=readpage3.bin status=none
          
          echo ""
          echo "test 3 분석 (빈 스페어)"
          
          SECTOR_STRING=$(dd if=readpage3.bin bs=1 count=512 status=none | strings | head -n 1)
          EXPECTED_SECTOR="xyz!!"
          
          if [ "$SECTOR_STRING" != "$EXPECTED_SECTOR" ]; then
          echo "❌ 섹터 문자열이 예상과 다름!"
          echo "💥 write-page-test 3 실패!"
          exit 1
          else
          echo "✅ 섹터 문자열 확인 완료: \"$SECTOR_STRING\""
          fi
          
          SPARE_HEX=$(xxd -s 512 -l 4 -p readpage3.bin)
          if [ "$SPARE_HEX" != "00000000" ]; then
          echo "❌ 빈 스페어는 0으로 저장되어야 함! → 현재 값: $SPARE_HEX"
          echo "💥 write-page-test 3 실패!"
          exit 1
          else
          echo "✅ 빈 스페어 → 0으로 정상 저장 (00000000)"
          echo "🎉 write-page-test 3 성공!"
          fi
          
          #############################
          # TEST 4: 섹터 + 스페어 모두 빈 경우
          #############################
          ./a.out c flashmemory 10
          ./a.out w flashmemory 8 "" ""
          
          dd if=flashmemory bs=528 skip=8 count=1 of=readpage4.bin status=none
          
          echo ""
          echo "test 4 분석 (섹터/스페어 모두 빈 입력)"
          
          # 섹터 영역 검증 (모두 0xFF)
          SECTOR_BYTES=$(dd if=readpage4.bin bs=1 count=512 status=none | hexdump -v -e '/1 "%02x"')
          
          if [[ "$SECTOR_BYTES" != $(printf 'ff%.0s' {1..512}) ]]; then
          echo "❌ 섹터 영역이 0xFF로 초기화되지 않음!"
          echo "💥 write-page-test 4 실패!"
          exit 1
          else
          echo "✅ 빈 섹터 → 섹터 영역이 0xFF로 초기화됨"
          fi
          
          # 스페어 영역 검증 (0으로 저장)
          SPARE_HEX=$(xxd -s 512 -l 4 -p readpage4.bin)
          if [ "$SPARE_HEX" != "00000000" ]; then
          echo "❌ 빈 스페어 → 0이 저장되지 않음! 현재: $SPARE_HEX"
          echo "💥 write-page-test 4 실패!"
          exit 1
          else
          echo "✅ 빈 스페어 → 0으로 정상 저장"
          echo "🎉 write-page-test 4 성공!"
          fi
          
          #############################
          # TEST 5: 기존 페이지에 덮어쓰기 방지
          #############################
          ./a.out c flashmemory 10
          ./a.out w flashmemory 9 "original" "99"
          
          # 첫 번째 쓰기 후 값 저장
          dd if=flashmemory bs=528 skip=9 count=1 of=before_overwrite.bin status=none
          
          # 덮어쓰기 시도 (같은 ppn = 9)
          ./a.out w flashmemory 9 "newdata" "55"
          
          # 다시 읽어서 비교
          dd if=flashmemory bs=528 skip=9 count=1 of=after_overwrite.bin status=none
          
          echo ""
          echo "test 5 분석 (덮어쓰기 방지 테스트)"
          
          # 🔍 before 내용 출력
          echo "📂 BEFORE 덮어쓰기 페이지 내용 (앞 64B)"
          hexdump -C before_overwrite.bin
          
          # 🔍 after 내용 출력
          echo "📂 AFTER 덮어쓰기 페이지 내용 (앞 64B)"
          hexdump -C after_overwrite.bin
          
          # 바이트 단위 값 비교를 위해 md5 해시로 비교
          HASH1=$(md5sum before_overwrite.bin | cut -d' ' -f1)
          HASH2=$(md5sum after_overwrite.bin | cut -d' ' -f1)
          
          if [ "$HASH1" != "$HASH2" ]; then
          echo "❌ 기존 데이터가 변경됨! 해시 불일치!"
          echo "💥 write-page-test 5 실패!"
          exit 1
          else
          echo "✅ 기존 데이터가 그대로 유지됨 (해시 일치)"
          echo "🎉 write-page-test 5 성공!"
          fi

      - name: read page
        run: |
          gcc ftlmgr.c fdevicedriver.c -o a.out
          
          ./a.out c flashmemory 10
          ./a.out w flashmemory 9 "abcd12345@%$" "99"
          READ_OUTPUT=$(./a.out r flashmemory 9)
          
          echo "📤 [TEST 1] 출력: $READ_OUTPUT"
          
          EXPECTED_OUTPUT="abcd12345@%$ 99"
          if [ "$READ_OUTPUT" != "$EXPECTED_OUTPUT" ]; then
          echo "❌ 출력 불일치!"
          echo "   기대값: $EXPECTED_OUTPUT"
          echo "   실제값: $READ_OUTPUT"
          exit 1
          else
          echo "✅ 출력 일치: $EXPECTED_OUTPUT"
          fi
          
          ./a.out c flashmemory 10
          ./a.out w flashmemory 8 "" "42"
          READ_OUTPUT=$(./a.out r flashmemory 8)
          echo "📤 [TEST 2] 출력: $READ_OUTPUT"
          if [ "$READ_OUTPUT" != "" ]; then
          echo "❌ TEST 2 실패 - 출력 불일치 (섹터 없음, 스페어 42)"
          exit 1
          else
          echo "✅ TEST 2 통과"
          fi
          
          
          ./a.out c flashmemory 10
          READ_OUTPUT=$(./a.out r flashmemory 7)
          echo "📤 [TEST 3] 출력: $READ_OUTPUT"
          if [ "$READ_OUTPUT" != "" ]; then
          echo "❌ TEST 3 실패 - 출력 불일치 (빈 페이지는 아무것도 출력하지 않아야 함)"
          exit 1
          else
          echo "✅ TEST 3 통과"
          fi

      - name: erase page
        run: |
          gcc ftlmgr.c fdevicedriver.c -o a.out
          
          ./a.out c flashmemory 10
          ./a.out w flashmemory 24 "erase_test_data" "777"
          ./a.out e flashmemory 3
          
          echo "블록 3의 모든 페이지가 0xFF로 초기화됐는지 확인"
          # 블록 3의 페이지 범위: ppn 24 ~ 31
          for i in $(seq 24 31); do
          dd if=flashmemory bs=528 skip=$i count=1 of=check_page.bin status=none
          
          # 528바이트가 모두 FF인지 검사
          NON_FF_COUNT=$(xxd -p check_page.bin | tr -d '\n' | grep -oE '[^fF]' | wc -l)
          if [ "$NON_FF_COUNT" -ne 0 ]; then
          echo "❌ ppn=$i 페이지가 0xFF로 완전히 초기화되지 않았습니다!"
          hexdump -C check_page.bin | head -n 4
          exit 1
          fi
          done
          echo "✅ erase-block-test 통과: 블록 3 전체가 정상적으로 삭제됨 (0xFF)"

      - name: In-place update
        run: |
          gcc ftlmgr.c fdevicedriver.c -o a.out
          
          ./a.out c flashmemory 10
          ./a.out w flashmemory 5 "abc123" "42"
          
          ./a.out u flashmemory 5 "abcd6789@%$" "30"
          
          echo "ppn=5에 sector와 spare가 정확히 갱신됐는지 확인"
          dd if=flashmemory bs=528 skip=5 count=1 of=check_page.bin status=none
          
          # sector 확인 (ASCII → HEX)
          EXPECT_SECTOR_HEX=$(echo -n "abcd6789@%$" | xxd -p | tr -d '\n')
          ACTUAL_SECTOR_HEX=$(xxd -p check_page.bin | tr -d '\n' | cut -c1-${#EXPECT_SECTOR_HEX})
          
          if [ "$EXPECT_SECTOR_HEX" != "$ACTUAL_SECTOR_HEX" ]; then
          echo "❌ 섹터 불일치!"
          echo "Expected: $EXPECT_SECTOR_HEX"
          echo "Actual  : $ACTUAL_SECTOR_HEX"
          hexdump -C check_page.bin | head -n 4
          exit 1
          fi
          
          # spare 확인 (정수형으로 저장됐다고 가정 → 4바이트 기준)
          EXPECT_SPARE_HEX=$(printf "%08x" 30 | sed 's/../& /g' | awk '{print $4$3$2$1}')
          SPARE_HEX=$(xxd -p check_page.bin | tr -d '\n' | cut -c1025-1032)
          
          if [ "$SPARE_HEX" != "$EXPECT_SPARE_HEX" ]; then
          echo "❌ 스페어 불일치!"
          echo "Expected: $EXPECT_SPARE_HEX"
          echo "Actual  : $SPARE_HEX"
          hexdump -C check_page.bin | head -n 4
          exit 1
          fi
          
          echo "✅ In-place update 테스트 통과: ppn=5의 sector/spare 정상 업데이트됨"