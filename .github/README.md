# 과제 2: Flash Device Driver 활용

## 1. 개요

“Flash Memory” 강의에서 배운 Flash device driver에 대한 이해를 높이고 이를 활용하는 프로그램을 구현하며, 다음과 같은 제약 사항을 따라야 한다.

- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.
- 아래의 (1), (2), (3), (4), (5)의 기능을 **ftlmgr.c**에 구현한다.
- 아래 (2), (3), (4), (5)의 기능은 **fdevicedriver.c**의 인터페이스를 이용하여 구현한다.
- **fdevicedriver.c**는 주어진 그대로 사용하며 수정해서는 안된다.

## (1) Flash Memory Emulator

Flash memory 저장 장치를 모방하는 flash memory 파일을 생성한다. 여기에는 **n**개의 블록과 각 블록에 **m**개의 페이지가 존재하며, 각 페이지는 하나의 512B 섹터영역(sector)과
16B 스페어영역(spare)으로 구성된다. 또한 블록은 8개의 페이지로 이루어져 있다 (즉, m=8). 아래의 명령어를 실행시키면 블록의 수 `<#blocks>`로 구성되는 flash memory 파일
`<flashfile>`을 생성한다.

```shell
a.out c <flashfile> <#blocks>
```

**예시**:

```shell
a.out c flashmemory 10
```

옵션으로 **c**를 사용하며, 10개의 블록과 각 블록은 8개의 물리적 페이지로 구성되는 flashmemory 파일을 생성한다 (파일 크기: 10*8*(512+16)=42,240B). 이때 모든 페이지의 모든
바이트는 0xFF로 초기화한다 (파일 전체를 0xFF로 채운다). Flash memory에서 ‘erase’ 연산도 결국 초기화 작업이기 때문에 파일에서 0xFF로 초기화하는 방법은 **fdevicedriver.c**
의 `fdd_erase()` 함수를 활용하거나 참고하여 프로그래밍한다.

> **주의:**
>
> - 생성한 flash memory 파일은 아래 (2), (3), (4)에서 사용한다.

## (2) 페이지 쓰기

Flash memory 저장장치에 페이지 단위로 데이터 쓰기를 수행한다. 아래 명령어를 실행시키면 `<flashfile>` 파일의 `<ppn>`의 물리적 페이지 번호를 가지는 페이지에, 섹터영역에는
`<sectordata>`를, 스페어영역에는 `<sparedata>`를 저장한다. 만약 `<flashfile>`의 블록의 수가 10이고 페이지 수가 8이면 `ppn=0, 1, 2, ..., 79`가 된다. 실제
`<sectordata>`와 `<sparedata>`는 각각 512B와 16B가 되어야 하나 화면상에서 입력하기 어려우므로 그 크기가 작아도 된다. 실행 결과를 화면에 출력할 필요가 없다.

```shell
a.out w <flashfile> <ppn> <sectordata> <sparedata>
```

**예시**:

```shell
a.out w flashmemory 5 "abcd12345@%$" "12"
```

옵션으로 **w**를 사용하며, `ppn=5` 즉, 6번째 페이지에 큰따옴표로 묶여있는 `abcd12345@%$`를 저장한다. 주어진 flashmemory 파일은 이미 생성되어 있어야 하며, 이 파일에는 최소한
6개의 페이지가 존재해야 한다. 주어진 섹터데이터를 해당 페이지의 섹터영역에 처음부터 차례로 저장한다. 만약 주어진 섹터데이터가 512B보다 적을 경우 나머지 공간은 0xFF로 채운다. `abcd12345@%$`를
6번째 페이지의 섹터영역에 처음부터 채우고 나머지 500B는 0xFF로 채운다. 스페어의 경우도 이와 같은 방식으로 처리한다.

> **주의:**
>
> - `<sectordata>`와 `<sparedata>`는 blank를 포함할 수 있기 때문에 큰따옴표로 데이터를 묶어서 입력한다. 그렇지 않는 경우 채점 시 정상적으로 동작하지 않는다.
> - 섹터 데이터와 스페어 데이터는 키보드로 입력할 수 있는 문자로 표현한다.
> - 이 명령어로는 동일한 페이지에 새로운 데이터로 갱신할 수 없다 (갱신을 위해서는 (5) 명령어를 사용해야 함).
> - `<sparedata>`는 정수가 사용되며, 따라서 스페어영역에 저장할 때 반드시 4Byte “binary integer” 모드로 저장한다. (주의: ASCII character 모드가 아님)

## (3) 페이지 읽기

Flash memory 저장장치에서 페이지 단위로 읽기를 수행한다. 아래 명령어를 실행시키면 `<flashfile>` 파일의 `<ppn>`의 물리적 페이지 번호를 가지는 페이지에 저장되어 있는 섹터 데이터와 스페어
데이터를 화면에 출력한다.

```shell
a.out r <flashfile> <ppn>
```

**예시**:

```shell
a.out r flashmemory 5
```

옵션으로 **r**를 사용하며, flashmemory 파일의 `ppn=5` 페이지에서 섹터영역의 데이터와 스페어영역의 데이터를 읽어서 화면에 출력한다. 위의 (2)의 예시와 같이 데이터를 저장하였다고 가정한 것이며,
섹터 데이터는 스페어영역에서 첫 번째 0xFF 전까지의 의미있는 데이터를, 스페어 데이터는 스페어영역에서 첫 4B의 정수값을 각각 출력한다.

> **주의:**
>
> - 읽어야 할 페이지의 섹터영역에 의미있는 데이터가 존재하지 않는 경우 (섹터에 0xFF만 저장되어 있는 경우) 화면에 아무것도 출력할 필요가 없다.

## (4) 블록 소거 (erase)

Flash memory 저장장치에서 블록 단위로 블록 소거를 수행한다. 아래 명령어를 실행시키면 `<flashfile>` 파일의 `<pbn>`의 물리적 블록번호를 가지는 블록을 소거한다. 화면에 실행 결과를 출력할
필요가 없다.

```shell
a.out e <flashfile> <pbn>
```

**예시**:

```shell
a.out e flashmemory 3
```

옵션 **e**를 사용하며, flashmemory 파일의 `pbn=3` 즉, 4번째 블록을 소거한다.

## (5) In-place update

위의 (2)에서 구현한 페이지 쓰기 명령어를 이용하여 Flash memory에 여러 번의 쓰기를 수행했다고 가정할 때, 이미 데이터가 존재하는 페이지에 갱신(update)이 발생하면 강의자료처럼 in-place
update를 수행한다. 강의자료처럼 해당 블록의 정상적인 페이지를 다른 페이지에 복사(copy)할 때 반드시 빈 블록을 하나 할당받아서 복사하는 제약을 둔다. 아래 명령어를 실행시키면 `<flashfile>`
파일의 `<ppn>` 번호의 페이지에 새로운 데이터 `<sectordata>`와 `<sparedata>`로 갱신한다.

```shell
a.out u <flashfile> <ppn> <sectordata> <sparedata>
```

**예시**:

```shell
a.out u flashmemory 11 "abcd6789@%$" "30"
```

``#reads=8 #writes=5 #erases=2``

옵션으로 **u**를 사용하며, flashmemory 파일의 `ppn=11` 즉, 12번째 페이지의 섹터영역과 스페어영역을 각각 `abcd6789@%$`와 `30`으로 갱신한다. 갱신하는 절차는 강의자료를 따른다.
갱신을 수행하는 과정에서 최소한의 읽기, 쓰기, 소거의 횟수를 각각 화면에 출력한다.

> **주의:**
>
> - `<sectordata>`와 `<sparedata>`는 blank를 포함할 수 있으므로 큰따옴표로 데이터를 묶어서 입력한다. 그렇지 않는 경우 채점 시 정상적으로 동작하지 않는다.
> - 섹터 데이터와 스페어 데이터는 키보드로 입력할 수 있는 문자로 표현한다.
> - 이 명령어를 이용하여 동일한 페이지에 여러 번 갱신을 수행할 수 있다.
> - `<sparedata>`는 정수가 사용되며, 따라서 스페어영역에 저장할 때 반드시 4Byte “binary integer” 모드로 저장한다. (주의: ASCII character 모드가 아님)
> - 반드시 위의 예시와 같이 출력 포맷을 따라야 한다.

## 2. 개발 환경

- **OS:** Linux 우분투 버전 22.04 LTS (Ubuntu 홈페이지에서 버전 확인 가능)
- **컴파일러:** gcc 13.2

* 과제 채점 환경은 위와 동일하며, 따라서 프로그램 개발 환경도 위의 환경에 맞추길 권장하며 이를 따르지 않아서 발생하는 불이익은 본인이 책임져야 함

## 3. 제출물

- 프로그래밍한 소스파일 **ftlmgr.c**를 하위폴더 없이 (최상위 위치에) zip 파일로 압축하여 스마트캠퍼스 [lms.ssu.ac.kr](https://lms.ssu.ac.kr)의 과제 게시판에 제출함 (
  모든 제출 파일들의 파일명은 반드시 소문자로 작성)
- 압축한 파일은 반드시 `학번_2.zip` (예시: `20201084_2.zip`)과 같이 작성하며, 여기서 2는 두 번째 과제임을 의미함

* 채점은 채점 프로그램을 통해 자동으로 처리하기 때문에 위의 사항들을 준수하지 않는 경우 채점 점수가 0이 될 수도 있기 때문에 반드시 준수하기 바라며, 이를 따르지 않아서 발생하는 불이익은 본인이 책임져야 함

---

# 채점기준-project2.pdf

과제2 채점기준 (총 100점)

1. 업로드 양식에 이상이 없으며, 소스파일이 모두 온전하고 컴파일에 문제가 없을 경우 **20점** 부여한다. (여기서 ‘온전’하다는 것은 열심히 프로그래밍을 하였다는 흔적을 의미)

2. 아래의 각 기능을 테스트하였을 때 다음과 같이 점수를 부여함 (부분 점수는 부여하지 않음):

    - **flash memory 파일 생성:** 프로그램 코드가 정확하며 그 실행 결과가 정확할 경우 **10점** 부여, 그렇지 않은 경우 **0점**
    - **페이지 쓰기:** 프로그램 코드가 정확하며 그 실행 결과가 정확할 경우 **20점** 부여, 그렇지 않은 경우 **0점**
    - **페이지 읽기:** 프로그램 코드가 정확하며 그 실행 결과가 정확할 경우 **20점** 부여, 그렇지 않은 경우 **0점**
    - **블록 소거:** 프로그램 코드가 정확하며 그 실행 결과가 정확할 경우 **10점** 부여, 그렇지 않은 경우 **0점**
    - **페이지 갱신:** 프로그램 코드가 정확하며 그 실행 결과가 정확할 경우 **20점** 부여, 그렇지 않은 경우 **0점**

3. 하루 늦게 제출할 때마다 **20점**씩 감점한다.

4. copy detection 프로그램을 수행하여 copy rate가 90 이상인 경우, 소스 확인 후 해당 두 학생에게 **0점**의 과제 점수를 부여하며, 두 번 이상 적발되는 경우 **F 학점**을
   부여한다. (강의 계획서 참조)

---